// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Imageinfo = require("imageinfo");
var MergeImg = require("merge-img");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Child_process = require("child_process");

var $$Node = {};

var Stats = {};

var Fs$1 = {
  Stats: Stats
};

var Path$1 = {};

var ImageInfo = {};

var MergeImg$1 = {};

var ChildProcess = {};

function toImageWithInfo(path) {
  var isPNG = path.endsWith(".png");
  if (!isPNG) {
    return ;
  }
  var file = Fs.readFileSync(path);
  var info = Imageinfo(file);
  if (info.format === "PNG" && info.width === 16 && info.height % 16 === 0) {
    return {
            path: path,
            info: info
          };
  }
  
}

function toValidImage(acc, image) {
  if (image !== undefined) {
    return acc.concat([image]);
  } else {
    return acc;
  }
}

function isDirectory(path) {
  return Fs.statSync(path).isDirectory();
}

var texturesOriginalDir = Path.resolve(__dirname, "./block-textures-original");

var texturesDir = Path.resolve(__dirname, "../../generators/minecraft-block/block-textures");

var dataFile = Path.resolve(__dirname, texturesDir + "/MinecraftBlock_TextureData.res");

var dirPaths = Fs.readdirSync(texturesOriginalDir).map(function (dirName) {
        return [
                dirName,
                texturesOriginalDir + "/" + dirName
              ];
      }).filter(function (param) {
      return Fs.statSync(param[1]).isDirectory();
    });

function makeVersions(param) {
  return dirPaths.map(function (param) {
              var dirPath = param[1];
              var fileNames = Fs.readdirSync(dirPath);
              var textures = fileNames.map(function (fileName) {
                          return dirPath + "/" + fileName;
                        }).map(toImageWithInfo).reduce(toValidImage, []).reduce((function (acc, image) {
                      var result = Path.parse(image.path);
                      var textureCount = acc.length;
                      var lastTexture = textureCount > 0 ? Caml_array.get(acc, textureCount - 1 | 0) : undefined;
                      var index = lastTexture !== undefined ? lastTexture.index + (lastTexture.frames << 4) | 0 : 0;
                      var texture_id = result.name;
                      var texture_filePath = dirPath + "/" + result.base;
                      var texture_frames = image.info.height / 16 | 0;
                      var texture = {
                        id: texture_id,
                        filePath: texture_filePath,
                        frames: texture_frames,
                        index: index
                      };
                      return acc.concat([texture]);
                    }), []);
              return {
                      id: param[0],
                      textures: textures
                    };
            });
}

function makeMergedTextureImages(versions) {
  return Promise.all(versions.map(function (param) {
                    var outPath = texturesDir + "/" + param.id + ".png";
                    var filePaths = param.textures.map(function (param) {
                          return param.filePath;
                        });
                    return MergeImg(filePaths, {
                                  direction: "vertical"
                                }).then(function (result) {
                                return new Promise((function (resolve, reject) {
                                              result.write(outPath, (function (error) {
                                                      if (error == null) {
                                                        return resolve(undefined);
                                                      } else {
                                                        return reject(error);
                                                      }
                                                    }));
                                              
                                            }));
                              });
                  })).then(function (param) {
              
            });
}

function makeVersionFileName(version) {
  return version.id.replace(/[-\.]/g, "_");
}

function makeDataFile(version) {
  var textures = version.textures.map(function (param) {
        return {
                id: param.id,
                frames: param.frames,
                index: param.index
              };
      });
  var versionData = {
    id: version.id,
    textures: textures
  };
  var standardHeight = versionData.textures.reduce((function (acc, texture) {
          return acc + (texture.frames << 4) | 0;
        }), 0);
  var textureData = {
    id: versionData.id,
    url: versionData.id + ".png",
    standardWidth: 16,
    standardHeight: standardHeight
  };
  var textureData$1 = "\n    {\n      id: \"" + textureData.id + "\",\n      url: Generator.requireImage(\"./" + textureData.url + "\"),\n      standardWidth: " + textureData.standardWidth.toString() + ",\n      standardHeight: " + textureData.standardHeight.toString() + ",\n    }\n  ";
  var code = "\n    // This is a generated file\n\n    let texture: Generator.textureDef = " + textureData$1 + "\n\n    let version = " + JSON.stringify(versionData) + "\n\n    let data = (texture, version)\n  ";
  var versionFileName = makeVersionFileName(version);
  console.log(makeVersionFileName(version));
  var fileName = "MinecraftBlock_Texture_" + versionFileName + ".res";
  var dataFile = Path.resolve(__dirname, texturesDir + ("/" + fileName));
  Fs.writeFileSync(dataFile, code);
  return new Promise((function (resolve, reject) {
                Child_process.exec("npx rescript format " + dataFile, (function (exn, stdout, stderr) {
                        if (exn == null) {
                          if (!(stdout == null)) {
                            console.log(stdout);
                          }
                          if (!(stderr == null)) {
                            console.log(stderr);
                          }
                          return resolve(undefined);
                        } else {
                          return reject(exn);
                        }
                      }));
                return resolve(undefined);
              }));
}

function makeDataFiles(versions) {
  return Promise.all(Belt_Array.map(versions, makeDataFile)).then(function (param) {
              return Promise.resolve(undefined);
            });
}

var versions = makeVersions(undefined);

$$Promise.$$catch(makeMergedTextureImages(versions).then(function (param) {
          return makeDataFiles(versions);
        }), (function (exn) {
        console.log(exn);
        return Promise.resolve(undefined);
      }));

exports.$$Node = $$Node;
exports.Fs = Fs$1;
exports.Path = Path$1;
exports.ImageInfo = ImageInfo;
exports.MergeImg = MergeImg$1;
exports.ChildProcess = ChildProcess;
exports.toImageWithInfo = toImageWithInfo;
exports.toValidImage = toValidImage;
exports.isDirectory = isDirectory;
exports.texturesOriginalDir = texturesOriginalDir;
exports.texturesDir = texturesDir;
exports.dataFile = dataFile;
exports.dirPaths = dirPaths;
exports.makeVersions = makeVersions;
exports.makeMergedTextureImages = makeMergedTextureImages;
exports.makeVersionFileName = makeVersionFileName;
exports.makeDataFile = makeDataFile;
exports.makeDataFiles = makeDataFiles;
exports.versions = versions;
/* texturesOriginalDir Not a pure module */
